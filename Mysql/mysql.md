1. 存储引擎基于表而不是数据库。

2. InnoDB存储引擎

   1. 将数据放在一个逻辑的表空间
   2. 4.1之后将表单独存放在一个独立的idb文件中
   3. 支持裸设备建立表空间
   4. 通过多版本并发控制（MVCC）提高并发性，实现了四种隔离级别
   5. 使用next-key locking的策略避免幻读
   6. 提高插入缓存，二次写，自适应哈希索引，预读

3. InnoDB采用聚集方式，表的存储都是按照主键的顺序进行存放。没有主键会给每一行的记录生成一个6字节的ROWID，作为主键。

4. MyISAM

   1. 不支持事务，表锁，
   2. 支持全文索引
   3. 只缓存索引文件，不缓存数据文件

5. 数据完整性

   1. 实例完整性
      1. 保证一张表的有一个主键，用户可定义Primary Key或者Unique Key保证实例完整性
   2. 域完整性
      1. 选择合适的数据类型去报一个数据值满足特定条件
      2. 外键约束
      3. 触发器
      4. default约束强制完整性

6. InnoDB存储引擎提供的约束

   1. primary key
   2. unique key
   3. foreign key
   4. default
   5. not null

7. 索引与算法

   InnoDB支持B+树索引，全文索引，哈希索引

   1. InnoDB自动为表生成哈希索引，不可人为干预

8. B+树，平衡查找树

   1. 只找到被查找的数据所在的页，然后把页读入到内存，然后在内存中查找，得到查找的数据

   2. [InnoDB一棵B+树可以存放多少行数据？](https://www.cnblogs.com/leefreeman/p/8315844.html)

9. InnoDB的hash算法

   1. 采用连地址法
   2. h(k) = k mod m
   3. m取值为缓冲池（innodb_buffer_pool_size）的2倍数量的质数

# 锁

## 概念

解决数据库中共享数据的并发访问。InnoDB对行级别上对表上锁，提供一致性的非锁定读，行级锁支持，行级锁没有额外的开销，同时保证了并发性和一致性。

## 锁的类型

### 共享锁（行锁）

允许事务读一行数据。

事务A获取了行r的共享锁，事务B也可以获取行r的共享锁。这是**锁兼容**，如果事务C想要获取行r的排他锁，必须等事务A、B释放行r的共享锁，这是**锁不兼容**。

### 排他锁（行锁）

允许事务删除或更新一行数据

### 意向锁

### 一致性非锁定读

如果读取的数据正在被某个事务执行update或者delete操作，读取操作不会等到行上锁的释放，**相反地**，InnoDB会读取行的快照数据。快照数据为之前版本的数据。**提高了并发性**。

不同的事务隔离方式，读取的方式不同。
|        事务的隔离级别        | 脏读 | 不可重复读 | 幻读 |
| :--------------------------: | :--: | :--------: | :--: |
| 读未提交（read-uncommitted） |  是  |     是     |  是  |
| 不可重复读（read-committed） |  否  |     是     |  是  |
| 可重复读（repeatable-read）  |  否  |     是     |  是  |
|    串行化（serializable）    |  否  |     否     |  否  |
